# HTTP缓存机制

@(HTTP)


-------------------

[TOC]

## 浏览器缓存基本认识
1. 浏览器在加载资源时，先根据这个资源的一些HTTP header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源。
2. 当强缓存没有命中的时候，浏览器会发送一个请求到服务器，通过服务器端依据资源的另外一些HTTP header判断是否命中协商缓存。
3. 当协商缓存也没有命中的时候，就直接从服务器加载资源。


## 两类缓存规则

> 缓存指令：缓存指令是单向的，也就是说，在请求里设置的指令，在响应里不必设置相同的指令。（待测试）

### 强缓存

####  Expires 

服务端返回的响应头里`GMT格式`的到期时间。下一次请求时，浏览器从缓存中找到这个到期时间，与现在请求的时间做对比，如果请求时间小于到期时间，就直接使用缓存，否则，就像服务器请求数据，并重新缓存数据和到期时间。
> Expires是HTTP 1.0的规则，现在浏览器默认使用的是HTTP 1.1。由于它是一个绝对的时间，在服务器时间与客户端时间相差较大时，缓存容易出现问题，HTTP 1.1的版本使用`Cache-Control：max-age=xxx`一个相对时间替代。

##### 待测试问题
- 请求头中设置是否还有效
- HTTP1.1下使用是否有效
- 若有效，其优先级

#### Pragma

HTTP 1.0的字段，只有一个唯一的值`no-cache`，功能与`Cache-control:no-cache`相同，使浏览器不使用缓存直接向服务器请求数据。且`Pragma`兼容HTTP 1.0和HTTP 1.1，有时候为了做HTTP的向下兼容会使用`Expires`或者`Pragma`字段。

##### 待测试问题
- 优先级

#### Cache-Control 
1. 在请求和响应中都可能出现的指令：
- **max-age=xxx**：缓存内容的有效期是xxx秒；
- **no-cache**：使用协商缓存；
- **no-store**：不使用缓存。
- **no-transform**：针对代理服务器，让代理服务器不能对资源进行包括`Content-Encoding`、`Content-Range`、`Content-Type`header的修改，比如将图片资源的格式修改以便压缩资源大小的操作都会被这条指令阻止。（？？）
2. 只在请求中出现的指令：
- **only-if-cached**：如果有缓存就返回缓存，不和服务器交互，无缓存返回504；
- **min-fresh=seconds**：客户端希望获取到的资源至少有seconds的新鲜期；
- **max-stale=seconds**：可以使用已经失效的缓存，可设置时间控制在缓存失效之后seconds时间内仍然可以使用缓存；
3. 只在响应中出现的指令：
- **must-revalidate**：缓存使用之前必须去验证新鲜度，失败返回504；
- **proxy-revalidate**：适用于代理服务器；
- **public**：客户端和代理服务器都可以缓存；
-  **private**：客户端可以缓存；
-  **s-maxage=seconds**：原理同max-age，适用于共享缓存（代理服务器），在共享缓存中设置会覆盖max-age和Expires头。
 
4.  返回结果：
使用强缓存，如果命中缓存，则从缓存中取资源，状态码依然是`200（from memory cache/form disk cache）`，表示从内存中读取或者从硬盘中存取 。
5. 其他：
如果`Expires`和`Cache-Control:max-age=xxx`同时存在，`Cache-Control:max-age=xxx`的优先级更高。

### Cache-Control效果图
![Alt text](./first-get.png)
![Alt text](./first-get-time.png)
![Alt text](./second-get.png)
![Alt text](./second-get-time.png)

### 强缓存的应用
强缓存是前端性能优化强有力的工具，但是也会带来问题，当网站更新版本时（更新了静态资源），这时之前的缓存仍然在有效期之内，用户看到的就是旧的版本。


### 协商缓存
> 浏览器第一次请求数据时，服务器会在响应头里加上缓存标识（`Last-Modified/Etag`），与数据一起返回给客户端，当浏览器再次请求数据时，客户端在请求头里加上缓存标识（`If-Modified-Since/If-None-Match`）发送给服务器，服务器根据缓存标识判断是否使用缓存。

1. Last-Modified / If-Modified-Since：

`Last-Modified`是服务器响应请求时返回的资源最后修改时间，浏览器在再次请求时会在请求头加上`If-Modified-Since`，这个的值就是刚才的`Last-Modified`，服务器收到请求后，将`If-Modified-Since`与资源最后修改时间进行比对。

2. Etag / If-None-Match：
> 通过某种算法，给资源计算出一个唯一的标识，和`Last-Modified`一样，会在响应头中返回`Etag`值。

服务器响应请求时，返回浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。再次请求服务器时，服务器收到请求头后发现有`If-None-Match`就与被请求资源的唯一标识进行比对。

3. 返回结果：
 如果使用缓存，将返回304状态码和空的响应体，浏览器获取缓存中相应的资源，并保留缓存标识。如果不使用缓存，就正常返回数据和新的缓存标识，浏览器将新的资源和缓存标识缓存下来。

4. 区别：
为什么有了`Last-Modified`还需要`Etag`?
 - `Last-Modified`不能监测到`秒级`一下的改变，有些资源改动比较频繁，一秒内会发生N次改变，这个时候`Last-Modified`就无法使用了.
 - 有些静态资源会周期性的被修改，但是其内容并没有改变，当它被修改的时候，我们希望仍然使用缓存，不必发送`GET`请求.
 - 有些服务器无法返回精确的资源修改时间.

### 用户操作

| 用户操作   |  强缓存   | 协商缓存  |
| :------------ | :------------:| :---------: |
| 地址栏回车 | 有效  | 有效   |
| 页面连接跳转 | 有效 |  有效  |
| 新开窗口 | 有效 |  有效   |
| 前进后退 | 有效 |  有效  |
| F5刷新   | 无效 |  有效   |
| Ctrl+F5刷新 | 无效 |  无效   |

## 缓存实践

> 协商缓存与强缓存的区别就在于协商缓存每次都要向服务器验证一下缓存的有效性。如果想要尽可能的减少请求，更多的利用本地资源，就希望尽可能命中强缓存，但是当资源更新的时候又可以让客户端的缓存失效

	


### 遗留问题
- 哪些资源存memory cache，哪些存disk cache
- 负载均衡