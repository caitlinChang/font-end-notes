#### HTTP/2

> HTTP/2把HTTP分解成了“语义”和“语法”两个部分；

语义层不做改动，语法层做了天翻地覆的改造；

#### 头部压缩
**HTTP1.0缺陷**
在HTTP1.0中虽有`Content-Encoding`字段指定了报文体的编码方式，压缩报文体来节约带宽，但是却没有针对报文头的优化手段；由于报文头一般会携带`User-Agent`，`Cookie`，`Accept`等固定的头字段，但是`Body`却经常只有十几节；更甚的是，很多请求响应报文里有很多头字段是重复的，非常浪费；“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上；
**HPACK**
HTTP/2开发了专门的`HPACK`算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%～90%的高压缩率；

#### 二进制格式
**不再采用ACSII码传输，全面采用二进制格式**
1. 虽然对人不友好，但是大大方便了计算机的解析
2. 使用纯文本容易出现多义性，比如大小写，空白字符，回车换行等，程序在处理时必须用复杂的状态机，效率低还麻烦；

HTTP/2把原来的**报文体加报文头**的消息打散为数个小片的二进制`帧`，用`HEADERS`帧存放头数据，`DATA`帧存放实体数据。

**流**
引入了`流`的概念，即二进制帧的双向传输序列；但是这里的`流`是虚拟的，并不存在，它只是指ID相同的几个数据帧；

HTTP/2可以在**一个**TCP连接上用`流`**同时**发送**多个**碎片化的消息，即**多路复用**——多个往返通信都用同一个连接来处理；

多个请求和响应之间没有了顺序关系，不再需要排队等待，也就不会再出现**队头阻塞**问题；

> 在TCP层面还是会存在队首阻塞，需要等待ACK；

**服务器推送**
HTTP/2协议中定义了服务器不再是完全被动的响应请求，也可以新建`流`主动向客户端发送消息；

#### 强化安全

HTTP2.0不强制使用加密通信，但是由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以“**事实上**”的HTTP/2是加密的。

`h2`表示加密的HTTP/2，`h2c`表示明文的HTTP/2

> 加密版本的HTTP/2要求下层的通信协议必须是TLS1.2以上，还要支持前向安全和SNI，还把几百个弱密码套件列入了黑名单，不允许使用；

#### 协议栈
相比HTTP1.0 多了`HPACK`和`STREAM`，底层使用`TLS1.2+`协议；

#### 配置
> 要求nginx版本1.10+，openssl的版本高于1.0.2，http2只支持https协议的网站

在`listen`的端口后增加http2标识
```
server {
    listen       443 ssl http2;
    server_name  hostname.com;

    location / {
        proxy_pass http://localhost:12345;
    }
}
```

#### 结语

HTTP/2 和 HTTP1.0的异同


